
name: Fabric Deployment Pipeline

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read

env:
  FABRIC_PIPELINE_NAME: 'Git Deployment'   # exact display name in Fabric
  DEV_WORKSPACE_ID: ''   # Dev workspace ID (GUID) - leave empty to look up by name
  DEV_WORKSPACE_NAME: 'GIT-DEV'   # Dev workspace name (used if ID is empty)
  DEV_STAGE_NAME: 'Development'
  TEST_STAGE_NAME: 'Test'
  PROD_STAGE_NAME: 'Production'
  FABRIC_RESOURCE: 'https://api.fabric.microsoft.com'
  # Optional: set DEBUG to 1 in GitHub Actions env/vars to enable verbose logs
  DEBUG: '1'
  AZURE_CREDENTIALS: >-
    {"clientId":"${{ secrets.AZURE_CLIENT_ID }}","clientSecret":"${{ secrets.AZURE_CLIENT_SECRET }}","tenantId":"${{ secrets.AZURE_TENANT_ID }}","subscriptionId":"${{ secrets.AZURE_SUBSCRIPTION_ID }}"}
  FABRIC_GIT_PAT: ${{ secrets.FABRIC_GIT_PAT }}
  FABRIC_GIT_USERNAME: ${{ secrets.FABRIC_GIT_USERNAME }}

jobs:
  development:
    name: Development (approve + discover IDs)
    runs-on: ubuntu-latest
    environment: Fabric-Development
    steps:
      - uses: actions/checkout@v4

      - name: Azure login (service principal)
        uses: azure/login@v2
        with:
          creds: ${{ env.AZURE_CREDENTIALS }}

      - name: Sync Dev Workspace with Git and Validate
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $ProgressPreference = 'SilentlyContinue'

          function Log([string]$m){ Write-Host "[$(Get-Date -Format o)] $m" }
          function Fail([string]$m){ Write-Error $m; exit 1 }

          $fabricResource = "${{ env.FABRIC_RESOURCE }}"
          $token = az account get-access-token --resource $fabricResource --query accessToken -o tsv 2>&1
          if ([string]::IsNullOrWhiteSpace($token)) { Fail "Failed to acquire Fabric token." }

          function Invoke-FabricApi([string]$Method,[string]$Uri,[string]$BodyJson){
            $headers = @("Authorization=Bearer $token","Content-Type=application/json")
            $cliArgs = @('rest', '--method', $Method, '--uri', $Uri, '--headers') + $headers
            if ($BodyJson){ $tmp = New-TemporaryFile; $BodyJson | Out-File -Encoding utf8 -FilePath $tmp; $cliArgs += @('--body', "@$tmp") }

            $psi = New-Object System.Diagnostics.ProcessStartInfo
            $psi.FileName = "az"
            $psi.RedirectStandardError = $true
            $psi.RedirectStandardOutput = $true
            $psi.UseShellExecute = $false
            foreach ($arg in $cliArgs) { $psi.ArgumentList.Add($arg) }

            $p = [System.Diagnostics.Process]::Start($psi)
            $out = $p.StandardOutput.ReadToEnd()
            $err = $p.StandardError.ReadToEnd()
            $p.WaitForExit()

            if ($tmp -and (Test-Path $tmp)) { Remove-Item $tmp -Force }

            $status = ($err -split "`n" | Select-String -Pattern 'Status Code:\s*(\d+)' | ForEach-Object { $_.Matches[0].Groups[1].Value } | Select-Object -Last 1)
            [pscustomobject]@{ Status=$status; ExitCode=$p.ExitCode; OutJson=$out; ErrText=$err }
          }

          # Resolve workspace ID
          $workspaceId = "${{ env.DEV_WORKSPACE_ID }}"
          if ([string]::IsNullOrWhiteSpace($workspaceId)) {
            Log "Looking up workspace by name: ${{ env.DEV_WORKSPACE_NAME }}"
            $r = Invoke-FabricApi -Method GET -Uri "$fabricResource/v1/workspaces"
            if ($r.ExitCode -ne 0){ $r.ErrText | Out-Host; Fail "Failed listing workspaces" }
            $workspaces = ($r.OutJson | ConvertFrom-Json).value
            $workspace = $workspaces | Where-Object { $_.displayName -eq "${{ env.DEV_WORKSPACE_NAME }}" } | Select-Object -First 1
            if (-not $workspace){ Fail "Workspace '${{ env.DEV_WORKSPACE_NAME }}' not found" }
            $workspaceId = $workspace.id
          }
          Log "Dev Workspace ID: $workspaceId"

          # Check Git connection status
          Log "Checking workspace Git connection..."
          $r = Invoke-FabricApi -Method GET -Uri "$fabricResource/v1/workspaces/$workspaceId/git/connection"
          if ($r.ExitCode -ne 0 -or $r.Status -eq '404'){
            Fail "Workspace is not connected to Git. Please connect the workspace to a Git repository."
          }
          $gitConn = $r.OutJson | ConvertFrom-Json
          Log "Git connected to: $($gitConn.gitProviderDetails.organizationName)/$($gitConn.gitProviderDetails.projectName)/$($gitConn.gitProviderDetails.repositoryName)"
          Log "Git connection response keys: $([string]::Join(', ', $gitConn.PSObject.Properties.Name))"
          if ($gitConn.gitProviderDetails) {
            Log "Git provider details keys: $([string]::Join(', ', $gitConn.gitProviderDetails.PSObject.Properties.Name))"
          }
          if ("${{ env.DEBUG }}" -eq '1') {
            Log "Git connection response (debug):"
            $gitConn | ConvertTo-Json -Depth 6 | Out-Host
          }

          # Optionally configure Git credentials for service principal
          $gitConnectionId = $null
          if ($gitConn.PSObject.Properties.Name -contains 'gitConnectionId') { $gitConnectionId = $gitConn.gitConnectionId }
          elseif ($gitConn.PSObject.Properties.Name -contains 'connectionId') { $gitConnectionId = $gitConn.connectionId }
          elseif ($gitConn.PSObject.Properties.Name -contains 'id') { $gitConnectionId = $gitConn.id }

          $gitProviderType = $null
          if ($gitConn.PSObject.Properties.Name -contains 'gitProviderType') { $gitProviderType = $gitConn.gitProviderType }
          elseif ($gitConn.gitProviderDetails -and $gitConn.gitProviderDetails.PSObject.Properties.Name -contains 'gitProviderType') { $gitProviderType = $gitConn.gitProviderDetails.gitProviderType }
          if (-not $gitProviderType) { $gitProviderType = 'GitHub' }

          $gitPat = "${{ env.FABRIC_GIT_PAT }}"
          $gitUsername = "${{ env.FABRIC_GIT_USERNAME }}"

          if (-not [string]::IsNullOrWhiteSpace($gitPat)) {
            Log "Setting Git credentials for service principal via myGitCredentials..."
            $body = @{
              personalAccessToken = $gitPat
            }
            if ($gitConnectionId) { $body.gitConnectionId = $gitConnectionId }
            if ($gitProviderType) { $body.gitProviderType = $gitProviderType }
            if (-not [string]::IsNullOrWhiteSpace($gitUsername)) { $body.userName = $gitUsername }

            $r = Invoke-FabricApi -Method PATCH -Uri "$fabricResource/v1/workspaces/$workspaceId/git/myGitCredentials" -BodyJson ($body | ConvertTo-Json -Depth 5)
            if ($r.ExitCode -ne 0){
              $r.ErrText | Out-Host
              Write-Host "::warning::Failed to set Git credentials for service principal."
            }
            else {
              Log "Git credentials updated for service principal."
            }
          }
          else {
            Write-Host "::warning::FABRIC_GIT_PAT not set; skipping myGitCredentials update."
          }

          # Validate Git credentials for the service principal (fail fast)
          # and capture status response for updateFromGit request body
          Log "Validating Git credentials for service principal..."
          $r = Invoke-FabricApi -Method GET -Uri "$fabricResource/v1/workspaces/$workspaceId/git/status"
          if ($r.ExitCode -ne 0){
            if ($r.ErrText -like '*GitCredentialsNotConfigured*') {
              $r.ErrText | Out-Host
              Write-Host "::warning::Git credentials are not configured for the service principal. Skipping Git sync and pending-change checks."
              $skipGitChecks = $true
            }
            $r.ErrText | Out-Host
            if (-not $skipGitChecks) { Fail "Failed to validate Git credentials" }
          }
          $gitStatusResponse = $r.OutJson | ConvertFrom-Json

          # Sync workspace with Git (update from Git)
          Log "Syncing workspace with Git repository..."
          $updateBody = @{
            remoteCommitHash = $gitStatusResponse.remoteCommitHash
            workspaceHead    = $gitStatusResponse.workspaceHead
            options          = @{
              allowOverrideItems = $true
            }
          } | ConvertTo-Json -Depth 5
          
          $r = Invoke-FabricApi -Method POST -Uri "$fabricResource/v1/workspaces/$workspaceId/git/updateFromGit" -BodyJson $updateBody
          if ($r.ExitCode -ne 0){
            # Check for Git credentials not configured error
            if ($r.ErrText -like '*GitCredentialsNotConfigured*') {
              Write-Host "##[warning]Unable to sync workspace - Git credentials not configured for API caller."
              Write-Host "##[warning]The workspace is connected to Git, but the service principal needs additional permissions."
              Write-Host "##[warning]Grant the service principal access with: Workspace Admin or Contributor role"
              Write-Host "##[warning]Proceeding with pending changes check only..."
            }
            # Check if it's just "no changes" which is acceptable
            elseif ($r.ErrText -like '*NoChangesToPull*' -or $r.Status -eq '400') {
              Log "Workspace is already up to date with Git"
            } else {
              $r.ErrText | Out-Host
              Fail "Failed to sync workspace from Git (Status: $($r.Status))"
            }
          }
          else {
            Log "Workspace synced successfully from Git"
          }

          # Check for pending changes (uncommitted changes in workspace)
          Log "Checking for pending changes in workspace..."
          $gitStatus = $gitStatusResponse

            # Check if there are any changes that need to be committed
            $hasChanges = $false
            if ($gitStatus.changes -and $gitStatus.changes.Count -gt 0) {
              $hasChanges = $true
              Write-Host "##[error]Workspace has uncommitted changes that must be committed to Git before deployment:"
              foreach ($change in $gitStatus.changes) {
                Write-Host "##[error]  - $($change.itemType): $($change.displayName) [$($change.changeType)]"
              }
            }

            if ($hasChanges) {
              Fail "Deployment blocked: Dev workspace has pending changes. Please commit all changes to Git before running the pipeline."
            }

            Log "✓ Workspace is in sync with Git and has no pending changes"

      - name: Resolve Fabric Pipeline and Stage IDs (PowerShell)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $ProgressPreference = 'SilentlyContinue'

          function Log([string]$m){ Write-Host "[$(Get-Date -Format o)] $m" }
          function Fail([string]$m){ Write-Error $m; exit 1 }

          $DEBUG = "${{ env.DEBUG }}"
          if ($DEBUG -eq '1') { Set-PSDebug -Trace 1 }

          $fabricResource = "${{ env.FABRIC_RESOURCE }}"

          Log "Azure account context:"
          az account show --only-show-errors | Out-Host

          Log "Acquiring Fabric token..."
          $token = az account get-access-token --resource $fabricResource --query accessToken -o tsv 2>&1
          if ([string]::IsNullOrWhiteSpace($token)) { Fail "Failed to acquire Fabric token." }
          Log ("Token len={0}, preview={1}...{2}" -f $token.Length, $token.Substring(0,8), $token.Substring($token.Length-8,8))

          function Invoke-AzRestJson([string]$Method,[string]$Uri,[string]$BodyJson){
            $headers = @("Authorization=Bearer $token","Content-Type=application/json")
            $cliArgs = @('rest', '--method', $Method, '--uri', $Uri, '--headers') + $headers
            if ($BodyJson){ $tmp = New-TemporaryFile; $BodyJson | Out-File -Encoding utf8 -FilePath $tmp; $cliArgs += @('--body', "@$tmp") }

            $psi = New-Object System.Diagnostics.ProcessStartInfo
            $psi.FileName = "az"
            $psi.RedirectStandardError = $true
            $psi.RedirectStandardOutput = $true
            $psi.UseShellExecute = $false
            foreach ($arg in $cliArgs) { $psi.ArgumentList.Add($arg) }

            $p = [System.Diagnostics.Process]::Start($psi)
            $out = $p.StandardOutput.ReadToEnd()
            $err = $p.StandardError.ReadToEnd()
            $p.WaitForExit()

            $status = ($err -split "`n" | Select-String -Pattern 'Status Code:\s*(\d+)' | ForEach-Object { $_.Matches[0].Groups[1].Value } | Select-Object -Last 1)
            [pscustomobject]@{ Status=$status; ExitCode=$p.ExitCode; OutJson=$out; ErrText=$err }
          }

          # 1) List deployment pipelines (GET /v1/deploymentPipelines)
          #    Ref: Microsoft Learn — List Deployment Pipelines
          $r = Invoke-AzRestJson -Method GET -Uri "$fabricResource/v1/deploymentPipelines"
          if ($r.ExitCode -ne 0){ $r.ErrText | Out-Host; Fail "Failed listing pipelines (rc=$($r.ExitCode), http=$($r.Status))" }
          if ($r.Status -eq '401'){ Fail "Unauthorized (401). Token invalid/expired." }
          if ($r.Status -eq '403'){ Fail "Forbidden (403). Identity lacks Fabric permissions." }
          $pipelines = ($r.OutJson | ConvertFrom-Json).value

          $pipelineName = "${{ env.FABRIC_PIPELINE_NAME }}"
          $pipeline = $pipelines | Where-Object { $_.displayName -eq $pipelineName } | Select-Object -First 1
          if (-not $pipeline){
            $r.OutJson | Out-Host
            Fail "Deployment Pipeline '$pipelineName' not found by display name."
          }
          $pipelineId = $pipeline.id
          Log "Resolved pipeline: $pipelineName [$pipelineId]"

          # 2) List stages for pipeline (GET /v1/deploymentPipelines/{id}/stages)
          $r2 = Invoke-AzRestJson -Method GET -Uri "$fabricResource/v1/deploymentPipelines/$pipelineId/stages"
          if ($r2.ExitCode -ne 0){ $r2.ErrText | Out-Host; Fail "Failed listing stages (rc=$($r2.ExitCode), http=$($r2.Status))" }
          $stages = ($r2.OutJson | ConvertFrom-Json).value

          $devId  = ($stages | Where-Object { $_.displayName -eq "${{ env.DEV_STAGE_NAME }}"  } | Select-Object -ExpandProperty id -First 1)
          $testId = ($stages | Where-Object { $_.displayName -eq "${{ env.TEST_STAGE_NAME }}" } | Select-Object -ExpandProperty id -First 1)
          $prodId = ($stages | Where-Object { $_.displayName -eq "${{ env.PROD_STAGE_NAME }}" } | Select-Object -ExpandProperty id -First 1)

          if (-not $devId -or -not $testId -or -not $prodId){
            $r2.OutJson | Out-Host
            Fail "One or more stage IDs could not be resolved by display name."
          }

          Log "Stage IDs:"
          Log "  ${{ env.DEV_STAGE_NAME }}:  $devId"
          Log "  ${{ env.TEST_STAGE_NAME }}: $testId"
          Log "  ${{ env.PROD_STAGE_NAME }}: $prodId"

          Write-Host "Development stage validation complete. IDs resolved successfully."

  test:
    name: Promote to Test
    runs-on: ubuntu-latest
    needs: development
    environment: Fabric-Test
    steps:
      - uses: actions/checkout@v4

      - name: Azure login (service principal)
        uses: azure/login@v2
        with:
          creds: ${{ env.AZURE_CREDENTIALS }}

      - name: "Fabric deploy: Development → Test (PowerShell)"
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $ProgressPreference = 'SilentlyContinue'

          function Log([string]$m){ Write-Host "[$(Get-Date -Format o)] $m" }
          function Fail([string]$m){ Write-Error $m; exit 1 }

          $fabricResource = "${{ env.FABRIC_RESOURCE }}"
          $token = az account get-access-token --resource $fabricResource --query accessToken -o tsv 2>&1
          if ([string]::IsNullOrWhiteSpace($token)){ Fail "Failed to acquire Fabric token." }

          function Invoke-AzRestJson([string]$Method,[string]$Uri,[string]$BodyJson){
            $headers = @("Authorization=Bearer $token","Content-Type=application/json")
            $cliArgs = @('rest', '--method', $Method, '--uri', $Uri, '--headers') + $headers
            if ($BodyJson){ $tmp = New-TemporaryFile; $BodyJson | Out-File -Encoding utf8 -FilePath $tmp; $cliArgs += @('--body', "@$tmp") }

            $psi = New-Object System.Diagnostics.ProcessStartInfo
            $psi.FileName = "az"
            $psi.RedirectStandardError = $true
            $psi.RedirectStandardOutput = $true
            $psi.UseShellExecute = $false
            foreach ($arg in $cliArgs) { $psi.ArgumentList.Add($arg) }

            $p = [System.Diagnostics.Process]::Start($psi)
            $out = $p.StandardOutput.ReadToEnd()
            $err = $p.StandardError.ReadToEnd()
            $p.WaitForExit()

            $status = ($err -split "`n" | Select-String -Pattern 'Status Code:\s*(\d+)' | ForEach-Object { $_.Matches[0].Groups[1].Value } | Select-Object -Last 1)
            [pscustomobject]@{ Status=$status; ExitCode=$p.ExitCode; OutJson=$out; ErrText=$err }
          }

          # Discover pipeline and stage IDs
          Log "Discovering Fabric pipeline and stage IDs..."
          $r = Invoke-AzRestJson -Method GET -Uri "$fabricResource/v1/deploymentPipelines"
          if ($r.ExitCode -ne 0){ $r.ErrText | Out-Host; Fail "Failed listing pipelines" }
          $pipelines = ($r.OutJson | ConvertFrom-Json).value

          $pipelineName = "${{ env.FABRIC_PIPELINE_NAME }}"
          $pipeline = $pipelines | Where-Object { $_.displayName -eq $pipelineName } | Select-Object -First 1
          if (-not $pipeline){ Fail "Pipeline '$pipelineName' not found" }
          $pipelineId = $pipeline.id

          $r2 = Invoke-AzRestJson -Method GET -Uri "$fabricResource/v1/deploymentPipelines/$pipelineId/stages"
          if ($r2.ExitCode -ne 0){ $r2.ErrText | Out-Host; Fail "Failed listing stages" }
          $stages = ($r2.OutJson | ConvertFrom-Json).value

          $devId  = ($stages | Where-Object { $_.displayName -eq "${{ env.DEV_STAGE_NAME }}"  } | Select-Object -ExpandProperty id -First 1)
          $testId = ($stages | Where-Object { $_.displayName -eq "${{ env.TEST_STAGE_NAME }}" } | Select-Object -ExpandProperty id -First 1)

          if (-not $devId -or -not $testId){ Fail "Could not resolve source/target stage IDs" }
          Log "Pipeline: $pipelineId, Dev: $devId, Test: $testId"

          # Deploy from Dev to Test
          $deployUri = "$fabricResource/v1/deploymentPipelines/$pipelineId/deploy"
          $body = @{
            sourceStageId = $devId
            targetStageId = $testId
            note = "GH Dev→Test"
          } | ConvertTo-Json -Depth 5

          try {
            $resp = Invoke-WebRequest -Method Post -Uri $deployUri -Headers @{ Authorization = "Bearer $token"; 'Content-Type'='application/json'} -Body $body -ErrorAction Stop
            Write-Host "HTTP $($resp.StatusCode)"
            Write-Host "x-ms-operation-id: $($resp.Headers['x-ms-operation-id'])"
            Write-Host "Retry-After: $($resp.Headers['Retry-After'])"
            Write-Host "Location: $($resp.Headers['Location'])"
            # (Optional) You can poll $resp.Headers['Location'] to wait for completion if you want.
          }
          catch {
            $errorDetails = $_.ErrorDetails.Message
            $exMessage = $_.Exception.Message
            
            # Check for "NoItemsToDeploy" in either the error details or exception message
            if (($errorDetails -like '*NoItemsToDeploy*') -or ($exMessage -like '*NoItemsToDeploy*')) {
                 Write-Host "::warning::Deployment skipped: Source and Target stages are already in sync (no changes to deploy)."
                 exit 0
            }
            
            # For other errors, print details if available
            if ($errorDetails) {
                Write-Error "API Error: $errorDetails"
            } else {
                Write-Error "Error: $exMessage"
            }

            throw $_
          }

  production:
    name: Promote to Production
    runs-on: ubuntu-latest
    needs: test
    environment: Fabric-Production
    steps:
      - uses: actions/checkout@v4

      - name: Azure login (service principal)
        uses: azure/login@v2
        with:
          creds: ${{ env.AZURE_CREDENTIALS }}

      - name: "Fabric deploy: Test → Production (PowerShell)"
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $ProgressPreference = 'SilentlyContinue'

          function Log([string]$m){ Write-Host "[$(Get-Date -Format o)] $m" }
          function Fail([string]$m){ Write-Error $m; exit 1 }

          $fabricResource = "${{ env.FABRIC_RESOURCE }}"
          $token = az account get-access-token --resource $fabricResource --query accessToken -o tsv 2>&1
          if ([string]::IsNullOrWhiteSpace($token)){ Fail "Failed to acquire Fabric token." }

          function Invoke-AzRestJson([string]$Method,[string]$Uri,[string]$BodyJson){
            $headers = @("Authorization=Bearer $token","Content-Type=application/json")
            $cliArgs = @('rest', '--method', $Method, '--uri', $Uri, '--headers') + $headers
            if ($BodyJson){ $tmp = New-TemporaryFile; $BodyJson | Out-File -Encoding utf8 -FilePath $tmp; $cliArgs += @('--body', "@$tmp") }

            $psi = New-Object System.Diagnostics.ProcessStartInfo
            $psi.FileName = "az"
            $psi.RedirectStandardError = $true
            $psi.RedirectStandardOutput = $true
            $psi.UseShellExecute = $false
            foreach ($arg in $cliArgs) { $psi.ArgumentList.Add($arg) }

            $p = [System.Diagnostics.Process]::Start($psi)
            $out = $p.StandardOutput.ReadToEnd()
            $err = $p.StandardError.ReadToEnd()
            $p.WaitForExit()

            $status = ($err -split "`n" | Select-String -Pattern 'Status Code:\s*(\d+)' | ForEach-Object { $_.Matches[0].Groups[1].Value } | Select-Object -Last 1)
            [pscustomobject]@{ Status=$status; ExitCode=$p.ExitCode; OutJson=$out; ErrText=$err }
          }

          # Discover pipeline and stage IDs
          Log "Discovering Fabric pipeline and stage IDs..."
          $r = Invoke-AzRestJson -Method GET -Uri "$fabricResource/v1/deploymentPipelines"
          if ($r.ExitCode -ne 0){ $r.ErrText | Out-Host; Fail "Failed listing pipelines" }
          $pipelines = ($r.OutJson | ConvertFrom-Json).value

          $pipelineName = "${{ env.FABRIC_PIPELINE_NAME }}"
          $pipeline = $pipelines | Where-Object { $_.displayName -eq $pipelineName } | Select-Object -First 1
          if (-not $pipeline){ Fail "Pipeline '$pipelineName' not found" }
          $pipelineId = $pipeline.id

          $r2 = Invoke-AzRestJson -Method GET -Uri "$fabricResource/v1/deploymentPipelines/$pipelineId/stages"
          if ($r2.ExitCode -ne 0){ $r2.ErrText | Out-Host; Fail "Failed listing stages" }
          $stages = ($r2.OutJson | ConvertFrom-Json).value

          $testId = ($stages | Where-Object { $_.displayName -eq "${{ env.TEST_STAGE_NAME }}" } | Select-Object -ExpandProperty id -First 1)
          $prodId = ($stages | Where-Object { $_.displayName -eq "${{ env.PROD_STAGE_NAME }}" } | Select-Object -ExpandProperty id -First 1)

          if (-not $testId -or -not $prodId){ Fail "Could not resolve source/target stage IDs" }
          Log "Pipeline: $pipelineId, Test: $testId, Prod: $prodId"

          # Deploy from Test to Production
          $deployUri = "$fabricResource/v1/deploymentPipelines/$pipelineId/deploy"
          $body = @{
            sourceStageId = $testId
            targetStageId = $prodId
            note = "GH Test→Prod"
          } | ConvertTo-Json -Depth 5

          try {
            $resp = Invoke-WebRequest -Method Post -Uri $deployUri -Headers @{ Authorization = "Bearer $token"; 'Content-Type'='application/json'} -Body $body -ErrorAction Stop
            Write-Host "HTTP $($resp.StatusCode)"
            Write-Host "x-ms-operation-id: $($resp.Headers['x-ms-operation-id'])"
            Write-Host "Retry-After: $($resp.Headers['Retry-After'])"
            Write-Host "Location: $($resp.Headers['Location'])"
          }
          catch {
            $errorDetails = $_.ErrorDetails.Message
            $exMessage = $_.Exception.Message
            
            # Check for "NoItemsToDeploy" in either the error details or exception message
            if (($errorDetails -like '*NoItemsToDeploy*') -or ($exMessage -like '*NoItemsToDeploy*')) {
                 Write-Host "::warning::Deployment skipped: Source and Target stages are already in sync (no changes to deploy)."
                 exit 0
            }
            
            # For other errors, print details if available
            if ($errorDetails) {
                Write-Error "API Error: $errorDetails"
            } else {
                Write-Error "Error: $exMessage"
            }

            throw $_
          }
